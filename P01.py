# -*- coding: utf-8 -*-
"""cs480_P01_A20491333.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LcSC4ExAl-hqQmE5nYxvSTLRyVfrN4xV
"""

import sys
import timeit
from heapq import heappop, heappush

args = sys.argv[1:]

# exit if user does not enter two parameters
if len(args) != 2:
    print("ERROR: Not enough or too many input arguments.")
    exit()

# Defining the initial and goal state 
INITIAL = "NM" #Initial State
GOAL = "MS" #Goal State

# Loading the csv files
driving = open('/content/driving.csv')
straight = open('/content/straightline.csv')

# dictionary initialization 
state_neighbors = {}
straight_distances = {}

# enumerating list data
driving_enum = enumerate(driving)
straight_enum = enumerate(straight)

# Node class which hold all parents node and its cost
class Node:
    def __init__(self, state, parent, pathCost, heuristics, algorithm):
        self.STATE = state
        self.PARENT = parent
        self.COST = pathCost
        self.NEIGHBORS = {}
        self.HEURISTICS = heuristics
        if algorithm == 'greedy_best_first_search':
            self.EVAL = self.HEURISTICS
        elif algorithm == 'a_star_algorithm':
            self.EVAL = self.COST + self.HEURISTICS
        
    def getState(self):
        return self.STATE
        
    def getParent(self):
        return self.PARENT

    def getPathCost(self):
        return self.PATHCOST
        
    def getHeuristics(self):
        return self.HEURISTICS
      
    def getEval(self):
        return self.EVAL
      
    def __lt__(self, other):
        return self.getEval() < other.getEval()

# Fills two maps passed as inputs. State name to TreeNode and state name to distance to the target.
# The third input is the target name

stOrder = None
for index, row in driving_enum:
    if index == 0:
        # splitting data
        stOrder = row.split(",")[1:]
        stOrder[-1] = stOrder[-1][:-1]
        continue
    start = stOrder[index - 1]
    state_neighbors[start] = {}
    data = row.split(",")
    data[-1] = data[-1][:-1]
    for j in range(1, len(data)):
        value = int(data[j])
        if value in [0, -1]:
            continue
        state_neighbors[start][stOrder[j - 1]] = value
driving.close()

state_neighbors

for index, row in straight_enum:
    if index == 0 or index > len(stOrder):
        continue
    data = row.split(",")
    data[-1] = data[-1][:-1]
    start = stOrder[index - 1]
    for j in range(1, len(stOrder) + 1):
        if start == GOAL:
            straight_distances[stOrder[j - 1]] = int(data[j])
straight.close()

straight_distances

def greedy_best_first_search():
    # Starting time
    timeStart = timeit.default_timer()
    state = INITIAL
    # Creating initial node
    node = Node(state, None, float("inf"), 0, "greedy_best_first_search")
    node.NEIGHBORS = state_neighbors[INITIAL]
    node.COST = 0
    try:
        frtr = [[straight_distances[INITIAL],INITIAL,node]]
        reached_state = {INITIAL:node}
        finished = False
        while frtr:
            node = heappop(frtr)[2]
            if node.STATE == GOAL:
                finished = True
                break
            for neighbor in node.NEIGHBORS:
                if neighbor not in reached_state or node.COST + node.NEIGHBORS[neighbor] < reached_state[neighbor].COST:
                    if neighbor not in reached_state:
                        reached_state[neighbor] = Node(neighbor, None, float("inf"), 0, "greedy_best_first_search")
                        reached_state[neighbor].COST = node.COST + node.NEIGHBORS[neighbor]
                        reached_state[neighbor].NEIGHBORS = state_neighbors[neighbor]
                    reached_state[neighbor].COST = node.COST + node.NEIGHBORS[neighbor]
                    reached_state[neighbor].PARENT = node
                    heappush(frtr, [straight_distances[neighbor],neighbor,reached_state[neighbor]])
                    
        timeEnd = timeit.default_timer()
        totalCost = node.COST
        path_string = node.STATE
        while node.PARENT:
            node = node.PARENT
            path_string = node.STATE+" "+path_string

        path_list = path_string.split(' ')

        return "Greedy Best First: \n"+ "Initial: "+INITIAL+" | Goal: "+GOAL+" | Path: "+str(path_list)+"\nPath cost: "+str(totalCost)+" miles\nExecution time: "+str(timeEnd-timeStart)+" seconds"
    except:
        timeEnd = timeit.default_timer()
        return "Path not found / failure\nGreedy Best First: \n"+ "Initial: "+INITIAL+" | Goal: "+GOAL+" | Path: [NOT FOUND] \nPath cost: N/A miles\nExecution time: "+str(timeEnd-timeStart)+" seconds"

def a_star_algorithm():
    timeStart = timeit.default_timer()
    state = INITIAL
    node = Node(state, None, float("inf"), 0, "a_star_algorithm")
    node.NEIGHBORS = state_neighbors[INITIAL]
    node.COST = 0
    try:
        frtr = [[straight_distances[INITIAL],INITIAL,node]]
        reached_state = {INITIAL:node}
        finished = False
        while frtr:
            node = heappop(frtr)[2]
            if node.STATE == GOAL:
                finished = True
                break
            for neighbor in node.NEIGHBORS:
                if neighbor not in reached_state or node.COST + node.NEIGHBORS[neighbor] < reached_state[neighbor].COST:
                    if neighbor not in reached_state:
                        reached_state[neighbor] = Node(neighbor, None, float("inf"), 0, "greedy_best_first_search")
                        reached_state[neighbor].COST = node.COST + node.NEIGHBORS[neighbor]
                        reached_state[neighbor].NEIGHBORS = state_neighbors[neighbor]
                    reached_state[neighbor].COST = node.COST + node.NEIGHBORS[neighbor]
                    reached_state[neighbor].PARENT = node
                    heappush(frtr, [reached_state[neighbor].COST+straight_distances[neighbor],neighbor,reached_state[neighbor]]) # a_star_algorithm
                    
        timeEnd = timeit.default_timer()
        totalCost = node.COST
        path_string = node.STATE
        while node.PARENT:
            node = node.PARENT
            path_string = node.STATE+" "+path_string

        path_list = path_string.split(' ')


        return "A* : \n"+ "Initial: "+INITIAL+" | Goal: "+GOAL+" | Path: "+str(path_list)+"\nPath cost: "+str(totalCost)+" miles\nExecution time: "+str(timeEnd-timeStart)+" seconds"
    except:
        timeEnd = timeit.default_timer()
        return "Path not found / failure\nA*: \n"+ "Initial: "+INITIAL+" | Goal: "+GOAL+" | Path: [NOT FOUND] \nPath cost: N/A miles\nExecution time: "+str(timeEnd-timeStart)+" seconds"

print("SINGH, AMAN, A20491333 SOLUTION:\n")
print(greedy_best_first_search()+"\n \n"+a_star_algorithm())

